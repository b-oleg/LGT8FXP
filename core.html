

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ядро &mdash; LGT8FXP 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Система тактирования" href="clk.html" />
    <link rel="prev" title="Описание" href="overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            LGT8FXP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Содержание:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Описание</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Ядро</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">Обзор</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">Архитектура</a></li>
<li class="toctree-l2"><a class="reference internal" href="#alu">Арифметико-логическое устройство (ALU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sreg">Регистр состояния (SREG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">Рабочие регистры</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#x-y-z">Регистры X/Y/Z</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">Указатель стека</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">Инструкции, связанные с указателем стека</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sph-spl">Регистры указателя стека SPH/SPL</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">Временные характеристики выполнения инструкций</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">Сброс и обработка прерываний</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">Время отклика на прерывание</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="clk.html">Система тактирования</a></li>
<li class="toctree-l1"><a class="reference internal" href="udsc.html">Ускоритель вычислений (uDSC)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">LGT8FXP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Ядро</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/core.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>Ядро<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<ul class="simple">
<li><p>Низкое энергопотребление</p></li>
<li><p>Высокоэффективная RISC-архитектура</p></li>
<li><p>16-битное расширение LD/ST (для uDSU)</p></li>
<li><p>130 инструкций, из которых более 80% выполняются за один такт</p></li>
<li><p>Встроенная поддержка отладки в реальном времени (OCD)</p></li>
</ul>
<section id="id2">
<h2>Обзор<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>В этом разделе описывается архитектура и функции ядра LGT8FXP. Ядро является “мозгом” микроконтроллера (MCU) и отвечает за корректное выполнение программ. Поэтому ядро должно точно выполнять вычисления, управлять периферийными устройствами и обрабатывать различные прерывания.</p>
</section>
<section id="id3">
<h2>Архитектура<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<p><img alt="alt text" src="_images/core.png" /></p>
<p>Для достижения большей эффективности и параллелизма ядро LGT8FXP использует Гарвардскую архитектуру — раздельные шины для данных и команд.</p>
<p>Инструкции выполняются через оптимизированный двухступенчатый конвейер, который уменьшает количество неэффективных инструкций в конвейере и снижает количество обращений к FLASH-памяти программ, что, в свою очередь, снижает энергопотребление ядра.</p>
<p>Кроме того, в ядре LGT8FXP добавлен кэш инструкций (может кэшировать до 2 инструкций) на этапе выборки инструкций. Благодаря модулю предварительного выполнения в цикле выборки инструкций, частота обращений к FLASH-памяти программ дополнительно снижается. Многочисленные тесты показали, что ядро LGT8FXP может сократить количество обращений к FLASH-памяти примерно на 50% по сравнению с другими аналогичными архитектурами, что значительно снижает энергопотребление системы.</p>
<p>Ядро LGT8FXP имеет 32 8-битных высокоскоростных регистра общего назначения (Register file), что способствует выполнению арифметико-логических операций (ALU) за один такт. Обычно оба операнда для операций ALU берутся из регистров общего назначения, а результат операции ALU записывается в регистровый файл за один такт.</p>
<p>32 рабочих регистра, из которых 6 используются для создания трех 16-битных регистров. Эти регистры могут использоваться для косвенной адресации указателей, что позволяет обращаться к внешнему адресному пространству и пространству FLASH-памяти программ. Ядро LGT8FXP поддерживает 16-битные арифметические операции за один такт, что значительно повышает эффективность косвенной адресации. Эти три специальных 16-битных регистра в ядре LGT8FXP называются X, Y и Z, и они будут подробно описаны далее.</p>
<p>Арифметико-логическое устройство (ALU) поддерживает арифметические и логические операции между регистрами, а также между константами и регистрами. Также ALU может выполнять операции с одним регистром. После завершения операции ALU результат влияет на состояние ядра, и это состояние обновляется в регистре состояния (SREG).</p>
<p>Управление потоком программы осуществляется с помощью условных и безусловных переходов/вызовов, которые могут адресовать любую область программы. Большинство инструкций LGT8FXP являются 16-битными. Каждое адресное пространство программы соответствует одной 16-битной или 32-битной инструкции LGT8FXP.</p>
<p>Когда ядро реагирует на прерывание или вызов подпрограммы, адрес возврата (PC) сохраняется в стеке. Стек размещается в общей SRAM-памяти данных системы, поэтому размер стека ограничен только объемом SRAM и ее использованием. Все приложения, поддерживающие прерывания или вызовы подпрограмм, должны сначала инициализировать регистр указателя стека (SP), который доступен через пространство ввода-вывода (I/O). SRAM-память данных может быть доступна через пять различных режимов адресации. Внутреннее адресное пространство LGT8FXP линейно отображается в единое адресное пространство. Подробности см. в разделе, посвященном памяти.</p>
<p>Ядро LGT8FXP включает гибкий контроллер прерываний. Функции прерываний могут управляться с помощью глобального бита разрешения прерываний в регистре состояния. Каждое прерывание имеет собственный вектор. Приоритет прерывания соответствует адресу вектора прерывания: чем меньше адрес, тем выше приоритет.</p>
<p>Пространство ввода-вывода (I/O) содержит 64 регистра, которые могут быть напрямую адресованы с помощью инструкций IN/OUT. Эти регистры управляют функциями ядра, регистрами состояния, SPI и другими периферийными устройствами ввода-вывода. Это пространство может быть доступно напрямую через инструкции IN/OUT или через их отображение в адресное пространство данных (0x20 – 0x5F). Кроме того, LGT8FX8P включает расширенное пространство ввода-вывода, которое отображается в адресное пространство данных 0x60 – 0xFF и доступно только через инструкции ST/STS/STD и LD/LDS/LDD.</p>
<p>Для повышения вычислительной мощности ядра LGT8FXP в конвейер инструкций добавлено 16-битное расширение LD/ST. Это расширение работает в сочетании с 16-битным блоком ускорения вычислений (uDSU), обеспечивая эффективные 16-битные операции. Также ядро поддерживает 16-битный доступ к RAM-памяти. Таким образом, 16-битное расширение LD/ST позволяет передавать 16-битные данные между uDSU, RAM и рабочими регистрами. Подробности см. в разделе “Блок ускорения вычислений”.</p>
</section>
<section id="alu">
<h2>Арифметико-логическое устройство (ALU)<a class="headerlink" href="#alu" title="Link to this heading"></a></h2>
<p>Ядро LGT8FXP включает 16-битное арифметико-логическое устройство, способное выполнять 16-битные арифметические операции за один такт. Эффективное ALU связано с 32 регистрами общего назначения и может выполнять арифметические и логические операции между двумя регистрами или между регистром и константой за один такт. Операции ALU делятся на три типа: арифметические, логические и побитовые. Кроме того, ALU включает однотактный аппаратный умножитель, который может выполнять умножение двух 8-битных регистров (знаковых или беззнаковых) за один такт. Подробности см. в разделе, посвященном набору инструкций.</p>
</section>
<section id="sreg">
<h2>Регистр состояния (SREG)<a class="headerlink" href="#sreg" title="Link to this heading"></a></h2>
<p>Регистр состояния хранит информацию о результатах последней операции ALU. Эта информация используется для управления потоком выполнения программы. Регистр состояния обновляется после завершения операции ALU, что позволяет избежать использования отдельных инструкций сравнения и делает код более компактным и эффективным. Значение регистра состояния не сохраняется и не восстанавливается автоматически при входе и выходе из прерывания, это должно быть реализовано программно.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Регистр</p></th>
<th class="head"><p>Адрес</p></th>
<th class="head"><p>Значение по умолчанию</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SREG</p></td>
<td><p>0x3F (0x5F)</p></td>
<td><p>0x00</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Бит</p></th>
<th class="head"><p>Доступ</p></th>
<th class="head"><p>Имя</p></th>
<th class="head"><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>R/W</p></td>
<td><p>C</p></td>
<td><p>Флаг переноса указывает, что арифметическая или логическая операция привела к переносу. Подробности смотрите в описании инструкции.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>R/W</p></td>
<td><p>Z</p></td>
<td><p>Флаг нуля, указывающий, что результат арифметической или логической операции равен нулю. Пожалуйста, обратитесь к разделу описания инструкции</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>R/W</p></td>
<td><p>N</p></td>
<td><p>Знак «минус», указывающий, что арифметическая или логическая операция дает отрицательное число. Пожалуйста, обратитесь к разделу описания инструкции</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>R/W</p></td>
<td><p>V</p></td>
<td><p>Флаг переполнения, указывающий на переполнение результата двоичной операции дополнения. Пожалуйста, обратитесь к разделу описания инструкции</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>R/W</p></td>
<td><p>S</p></td>
<td><p>Знаковый бит, эквивалентный результату XOR N и V. Подробности см. в разделе описания инструкций.</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>R/W</p></td>
<td><p>H</p></td>
<td><p>Флаг полупереноса, полезный в работе с двоично-десятичным кодом, указывает, что операция с байтом генерирует полуперенос.</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>R/W</p></td>
<td><p>T</p></td>
<td><p>Временный бит, используемый в инструкциях копирования битов (BLD) и хранения битов (BST). Бит T будет использоваться как временный бит хранения для временного сохранения значения бита в общем регистре.Подробную информацию смотрите в разделе с описанием инструкции.</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>R/W</p></td>
<td><p>I</p></td>
<td><p>Глобальный бит разрешения прерываний. Этот бит должен быть установлен в 1, чтобы ядро ​​могло реагировать на события прерываний. Различные источники прерываний управляются независимыми битами управления. Глобальный бит разрешения прерываний — это последний барьер, который контролирует сигнал прерывания, поступающий в ядро. Бит I автоматически очищается аппаратно после того, как ядро ​​ответит на вектор прерывания, и автоматически устанавливается после выполнения инструкции возврата прерывания (RETI). Бит I также можно изменить с помощью инструкций SEI и CLI, см. раздел с описанием инструкций.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id4">
<h2>Рабочие регистры<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<p>Рабочие регистры оптимизированы в соответствии с архитектурой набора инструкций LGT8FXP. Для достижения эффективности и гибкости, необходимых для выполнения ядра, общие рабочие регистры внутри LGT8FXP поддерживают следующие режимы доступа:</p>
<ul class="simple">
<li><p>Одна 8-битная операция чтения и одна 8-битная операция записи одновременно</p></li>
<li><p>Два 8-битных чтения и одна 8-битная запись одновременно</p></li>
<li><p>Две 8-битные операции чтения и одна 16-битная операция записи одновременно</p></li>
<li><p>Одновременная операция чтения и записи 16-битных данных</p></li>
</ul>
<p><img alt="Рабочие регистры" src="_images/core-reg.png" /></p>
<p>Большинство инструкций могут напрямую обращаться ко всем общим рабочим регистрам, и большинство из них являются однотактовыми инструкциями.
Как показано на рисунке выше, каждый регистр соответствует адресу в пространстве хранения данных, и эти общие рабочие регистры отображаются в пространстве хранения данных. Хотя на самом деле они не существуют в SRAM, эта единообразно отображаемая организация хранения данных обеспечивает большую гибкость в доступе к ним. Регистры X/Y/Z можно использовать в качестве указателей для индексации любого регистра общего назначения.</p>
<section id="x-y-z">
<h3>Регистры X/Y/Z<a class="headerlink" href="#x-y-z" title="Link to this heading"></a></h3>
<p>Регистры R26…R31 можно объединять попарно, образуя три 16-битных регистра. Эти три 16-битных регистра в основном используются для адресных указателей косвенного адресного доступа. Структура регистров X/Y/Z следующая:</p>
<p><img alt="Регистры X/Y/Z" src="_images/core-xyz.png" /></p>
<p>В различных режимах адресации эти регистры используются как указатели с фиксированным смещением, автоинкрементные и автодекрементные указатели адреса. Подробности см. в разделе описания инструкций.</p>
</section>
</section>
<section id="id5">
<h2>Указатель стека<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<p>Стек используется для хранения временных данных, локальных переменных, а также адресов возврата при вызовах подпрограмм и прерываний. Важно отметить, что стек разработан для роста от старших адресов к младшим. Регистр указателя стека (SP) всегда указывает на вершину стека. Указатель стека указывает на физическое пространство SRAM, где находится стек, необходимый для вызовов подпрограмм или прерываний. Инструкция <strong>PUSH</strong> приводит к уменьшению указателя стека.</p>
<p>Положение стека в SRAM должно быть правильно установлено программным обеспечением перед выполнением подпрограмм или включением прерываний. Обычно указатель стека инициализируется на самый верхний адрес SRAM. Указатель стека должен быть установлен на начало старших адресов SRAM. Адреса SRAM в системном отображении памяти данных см. в разделе системной памяти данных.</p>
<section id="id6">
<h3>Инструкции, связанные с указателем стека<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Инструкция</p></th>
<th class="head"><p>Указатель стека</p></th>
<th class="head"><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PUSH</p></td>
<td><p>Увеличивается на 1</p></td>
<td><p>Данные помещаются в стек</p></td>
</tr>
<tr class="row-odd"><td><p>CALL, ICALL, RCALL</p></td>
<td><p>Увеличивается на 2</p></td>
<td><p>Адрес возврата при вызове подпрограммы или прерывания помещается в стек</p></td>
</tr>
<tr class="row-even"><td><p>POP</p></td>
<td><p>Уменьшается на 1</p></td>
<td><p>Данные извлекаются из стека</p></td>
</tr>
<tr class="row-odd"><td><p>RET, RETI</p></td>
<td><p>Уменьшается на 2</p></td>
<td><p>Адрес возврата извлекается из стека</p></td>
</tr>
</tbody>
</table>
<p>Указатель стека состоит из двух 8-битных регистров, расположенных в пространстве ввода-вывода (I/O). Фактическая длина указателя стека зависит от реализации системы. В некоторых реализациях архитектуры LGT8FXP объем данных настолько мал, что для адресации достаточно только регистра SPL. В таких случаях регистр SPH не используется.</p>
</section>
<section id="sph-spl">
<h3>Регистры указателя стека SPH/SPL<a class="headerlink" href="#sph-spl" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Регистр</p></th>
<th class="head"><p>Адрес</p></th>
<th class="head"><p>Значение по умолчанию</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SPH</p></td>
<td><p>0x3E (0x5E)</p></td>
<td><p>RAMEND</p></td>
</tr>
<tr class="row-odd"><td><p>SPL</p></td>
<td><p>0x3D (0x5D)</p></td>
<td><p>RAMEND</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Бит</p></th>
<th class="head"><p>Доступ</p></th>
<th class="head"><p>Имя</p></th>
<th class="head"><p>Описание</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>7:0</p></td>
<td><p>R/W</p></td>
<td><p>SPL</p></td>
<td><p>Младшие 8 бит указателя стека</p></td>
</tr>
<tr class="row-odd"><td><p>15:8</p></td>
<td><p>R/W</p></td>
<td><p>SPH</p></td>
<td><p>Старшие 8 бит указателя стека</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id7">
<h2>Временные характеристики выполнения инструкций<a class="headerlink" href="#id7" title="Link to this heading"></a></h2>
<p>Этот раздел описывает общие временные характеристики выполнения инструкций. Ядро LGT8FXP управляется тактовым сигналом ядра (CLKcpu), который поступает непосредственно от схемы выбора системного тактового сигнала.</p>
<p><img alt="Временная диаграмма" src="_images/core-clk-cpu.png" /></p>
<p>На следующем рисунке показана временная диаграмма выполнения инструкций на основе концепции Гарвардской архитектуры и быстрого доступа к регистровому файлу. Это обеспечивает физическую гарантию эффективности выполнения ядра на уровне 1 MIPS/MHz.</p>
<p>Из рисунка видно, что во время выполнения первой инструкции одновременно происходит чтение второй инструкции. Когда вторая инструкция начинает выполняться, одновременно читается третья инструкция. Таким образом, в течение всего времени выполнения не требуется тратить дополнительные циклы на чтение инструкций, что позволяет достичь эффективности выполнения одной инструкции за каждый такт.</p>
<p>На следующем рисунке показана временная диаграмма доступа к регистрам общего назначения. В течение одного такта ALU использует два регистра в качестве операндов и записывает результат выполнения ALU в целевой регистр в том же такте.</p>
<p><img alt="Временная диаграмма" src="_images/core-clk-alu.png" /></p>
</section>
<section id="id8">
<h2>Сброс и обработка прерываний<a class="headerlink" href="#id8" title="Link to this heading"></a></h2>
<p>LGT8FXP поддерживает несколько источников прерываний. Эти прерывания, а также вектор сброса, имеют отдельные точки входа в программном пространстве. Как правило, каждое прерывание имеет отдельный управляющий бит. Когда этот бит установлен и включен глобальный бит разрешения прерываний в ядре, ядро может реагировать на это прерывание.</p>
<p>Нижняя часть программного пространства по умолчанию зарезервирована для векторов сброса и прерываний. Полный список прерываний, поддерживаемых LGT8FX8P, приведен в разделе, посвященном прерываниям. Этот список также определяет приоритеты прерываний. Прерывания с более низкими адресами векторов имеют более высокий приоритет. Сброс (RESET) имеет наивысший приоритет, за ним следует INT0 – внешний запрос прерывания 0. Начальный адрес таблицы векторов прерываний (за исключением вектора сброса) может быть переопределен на любое выравненное по 256 байт начало с помощью бита IVSEL в регистре управления MCU (MCUCR) и регистра базового адреса векторов IVBASE.</p>
<p>Когда ядро реагирует на прерывание, глобальный флаг разрешения прерываний I автоматически сбрасывается аппаратно. Пользователь может включить вложенные прерывания, установив бит I. В этом случае любое последующее прерывание может прервать текущую процедуру обработки прерывания. Бит I автоматически устанавливается при выполнении инструкции возврата из прерывания (RETI), что позволяет нормально реагировать на последующие прерывания.</p>
<p>Существует два основных типа прерываний. Первый тип инициируется событием, которое устанавливает флаг прерывания. Для таких прерываний, когда ядро реагирует на запрос прерывания, текущее значение PC заменяется на адрес вектора прерывания, и выполняется соответствующая процедура обработки прерывания, при этом флаг прерывания автоматически сбрасывается аппаратно. Флаг прерывания также может быть сброшен путем записи 1 в соответствующую позицию флага. Если прерывание происходит, когда бит разрешения прерывания сброшен, флаг прерывания все равно будет установлен для регистрации события прерывания. Когда прерывание будет разрешено, это зарегистрированное событие будет немедленно обработано. Аналогично, если глобальный бит разрешения прерываний (SREG.I) сброшен при возникновении прерывания, соответствующий флаг прерывания будет установлен для регистрации события прерывания, и когда глобальный бит разрешения прерываний будет установлен, эти зарегистрированные прерывания будут обработаны в соответствии с их приоритетами.</p>
<p>Второй тип прерываний возникает, когда условие прерывания сохраняется, и прерывание продолжает обрабатываться. Для таких прерываний не требуется флаг прерывания. Если условие прерывания исчезает до того, как прерывание будет разрешено, это прерывание не будет обработано.</p>
<p>Когда ядро LGT8FXP завершает выполнение процедуры обработки прерывания, управление возвращается в основную программу. В основной программе должно быть выполнено одна или несколько инструкций, прежде чем можно будет обработать другие ожидающие запросы прерываний.</p>
<p>Важно отметить, что регистр состояния системы (SREG) не сохраняется автоматически при входе в процедуру обработки прерывания и не восстанавливается автоматически при выходе из нее. Это должно быть обработано программно.</p>
<p>Когда прерывания запрещены с помощью инструкции CLI, прерывания немедленно отключаются. Никакие прерывания, происходящие после выполнения инструкции CLI, не будут обработаны. Даже прерывания, происходящие одновременно с выполнением CLI, не будут обработаны. В следующем примере показано, как использовать CLI для предотвращения нарушения временных характеристик записи в EEPROM из-за прерываний:</p>
<p>Пример кода на Ассемблере</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IN</span> <span class="n">R16</span><span class="p">,</span> <span class="n">SREG</span>    <span class="p">;</span> <span class="n">сохранить</span> <span class="n">значение</span> <span class="n">SREG</span>
<span class="n">CLI</span>             <span class="p">;</span> <span class="n">отключить</span> <span class="n">прерывания</span>
<span class="n">SBI</span> <span class="n">EECR</span><span class="p">,</span> <span class="n">EEMPE</span> <span class="p">;</span> <span class="n">начать</span> <span class="n">запись</span> <span class="n">EEPROM</span>
<span class="n">SBI</span> <span class="n">EECR</span><span class="p">,</span> <span class="n">EEPE</span>
<span class="n">OUT</span> <span class="n">SREG</span><span class="p">,</span> <span class="n">R16</span>   <span class="p">;</span> <span class="n">восстановить</span> <span class="n">значение</span> <span class="n">SREG</span> <span class="p">(</span><span class="n">включая</span> <span class="n">бит</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>Пример кода на языке С</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="n">cSREG</span><span class="p">;</span>
<span class="n">cSREG</span> <span class="o">=</span> <span class="n">SREG</span><span class="p">;</span>           <span class="o">//</span> <span class="n">сохранить</span> <span class="n">значение</span> <span class="n">SREG</span>
<span class="n">_CLI</span><span class="p">();</span>                 <span class="o">//</span> <span class="n">отключить</span> <span class="n">прерывания</span>
<span class="n">EECR</span> <span class="o">|</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">EEMPE</span><span class="p">);</span>  <span class="o">//</span> <span class="n">начать</span> <span class="n">запись</span> <span class="n">EEPROM</span>
<span class="n">EECR</span> <span class="o">|</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">EEPE</span><span class="p">);</span>
<span class="n">SREG</span> <span class="o">=</span> <span class="n">cSREG</span><span class="p">;</span>           <span class="o">//</span> <span class="n">восстановить</span> <span class="n">значение</span> <span class="n">SREG</span> <span class="p">(</span><span class="n">включая</span> <span class="n">бит</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>Когда прерывания разрешены инструкцией SEI, команда, следующая за инструкцией SEI, будет выполнена до того, как прерывание сработает, например:</p>
<p>Пример кода на Ассемблере</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SEI</span>             <span class="p">;</span> <span class="n">установить</span> <span class="n">глобальный</span> <span class="n">флаг</span> <span class="n">разрешения</span> <span class="n">прерываний</span>
<span class="n">SLEEP</span>           <span class="p">;</span> <span class="n">переход</span> <span class="n">в</span> <span class="n">режим</span> <span class="n">сна</span><span class="p">,</span> <span class="n">ожидая</span> <span class="n">прерывания</span>
<span class="p">;</span> <span class="n">note</span><span class="p">:</span> <span class="n">войдет</span> <span class="n">в</span> <span class="n">сон</span> <span class="n">перед</span> <span class="n">любым</span> <span class="n">ожидающим</span> <span class="n">прерыванием</span>
</pre></div>
</div>
<p>Пример кода на языке С</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__enable_interrupt</span> <span class="p">();</span>  <span class="o">//</span> <span class="n">установить</span> <span class="n">глобальный</span> <span class="n">флаг</span> <span class="n">разрешения</span> <span class="n">прерываний</span>
<span class="n">__sleep</span><span class="p">();</span>              <span class="o">//</span> <span class="n">переход</span> <span class="n">в</span> <span class="n">режим</span> <span class="n">сна</span><span class="p">,</span> <span class="n">ожидая</span> <span class="n">прерывания</span>
<span class="o">//</span> <span class="n">note</span><span class="p">:</span> <span class="n">войдет</span> <span class="n">в</span> <span class="n">сон</span> <span class="n">перед</span> <span class="n">любым</span> <span class="n">ожидающим</span> <span class="n">прерыванием</span>
</pre></div>
</div>
</section>
<section id="id9">
<h2>Время отклика на прерывание<a class="headerlink" href="#id9" title="Link to this heading"></a></h2>
<p>Ядро LGT8FXP оптимизировано для быстрого реагирования на прерывания, что гарантирует обработку любого прерывания в течение 4 системных тактов. Через 4 системных такта начинается выполнение процедуры обработки прерывания. В течение этих 4 тактов значение PC (счетчика команд) до прерывания сохраняется в стеке, и выполнение программы переходит к процедуре обработки прерывания, соответствующей вектору прерывания. Если прерывание происходит во время выполнения многотактной инструкции, ядро гарантирует корректное завершение текущей инструкции.</p>
<p>Если прерывание происходит, когда система находится в режиме сна (SLEEP), время отклика на прерывание увеличивается на дополнительные 4 такта. Эти дополнительные такты необходимы для синхронизации при выходе из выбранного режима сна. Подробное описание режимов сна см. в разделе, посвященном управлению энергопотреблением.</p>
<p>Возврат из процедуры обработки прерывания занимает 2 такта. В течение этих 2 тактов значение PC восстанавливается из стека, указатель стека увеличивается на 2, и глобальный бит разрешения прерываний автоматически включается.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="overview.html" class="btn btn-neutral float-left" title="Описание" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="clk.html" class="btn btn-neutral float-right" title="Система тактирования" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright b-oleg.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>